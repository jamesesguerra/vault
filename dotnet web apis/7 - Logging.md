> **logging** is the process of keeping track of events occurring within an application in a structured / unstructured format, outputting them to a dedicated channel

see also [[1 - Adding Logging]]

### `ILogger`
Logging APIs are made available through the `ILogger` interface, which allows us to log through a series of built-in or third party logging providers.

### Logging configuration
The `LogLevel` values seen in an application's app settings correspond to the **minimum level to log** for each category.

The categories are:
- `Default` - allows you to configure the logging verbosity of general logging throughout your app, including custom application code and any code not tied to the .NET Core infrastructure
- `Microsoft.AspNetCore` - control logging verbosity for .NET Core's internal operations

Keep in mind that you can also customize the log level for individual logging providers through the app settings as well.

### Logging Providers
Logging providers are components that store and display logs. It receives logs sent by the `ILogger` APIs and store / show them somewhere.

You can attach multiple providers to the `ILogger` to store and display logs simultaneously to different places. For example, you can add console and debug providers like this:
```csharp
builder.Logging
	.ClearProviders()
	.AddSimpleConsole()
	.AddDebug();
```

These providers can be configured as well through the app settings file:
```json
{  
  "Logging": {    
    "Console": {  
      "FormatterOptions": {  
        "SingleLine": true,  
        "TimestampFormat": "HH:mm:ss",  
        "UseUtcTimestamp": true  
	  }  
	}
  }
}
```

### Event IDs
You can classify logs that come from different event categories by passing a number that represents something. These logs typically mean something to your app and have something in common.

```csharp
_logger.LogInformation(50110, "Get method started");
```

It can really be useful to classify your log events to group / filter them together when debugging / doing audit activities. You can create a custom `CustomLogEvents` class to define them in a central place.

```csharp
public class CustomLogEvents  
{  
    public const int BoardGamesController_Get = 50110;  
    public const int BoardGamesController_Post = 50120;  
    // ...
}
```

#### Exception Handling
You can use the web application instance's logger in `Program.cs` to log errors in the error handler endpoint.

```csharp
app.MapGet("/error", [ResponseCache(NoStore = true)] (HttpContext context) =>  
{  
    var exceptionHandler = context.Features.Get<IExceptionHandlerPathFeature>();  
  
    app.Logger.LogError(  
        exceptionHandler?.Error,  
        "An unhandled error occured"); 
         
    return Results.Problem(details);  
});
```

### Configuring an Azure Application Insights Provider
Azure Monitor is a comprehensive solution to collect and analyze logs, audit trails, and other performance-related output from a wide-range of services including web applications. **Application Insights** is a feature of Azure Monitor dedicated to ingesting, monitoring, and analyzing the log messages generated by web applications.

1. Create the Application Insights instance on Azure

2. Copy the connection string of the instance and add it as a configuration parameter 
```sh
dotnet user-secrets set "Azure:ApplicationInsights:ConnectionString" "<connection-string>"
```

3. Install the NuGet packages for the Azure Application Insights provider
```bash
dotnet add package Microsoft.Extensions.Logging.ApplicationInsights # the provider itself
dotnet add package Microsoft.ApplicationInsights.AspNetCore # to configure it with appsettings
```

4. Configure the Application Insights provider.
```csharp
builder.Logging  
    .ClearProviders()  
    .AddSimpleConsole()  
    .AddDebug()  
    .AddApplicationInsights(  
        telemetry => telemetry.ConnectionString  
            = builder.Configuration["Azure:ApplicationInsights:ConnectionString"],  
        _ => { });
```

### Serilog
A third-party logging library allows you to store structured logs anywhere else, including DBMSes. You can configure it to be either a logging API (replacing the `ILogger` interface) or a logging provider, extending the Microsoft logging API with features.

It provides two main advantages over other logging providers:
- **enrichers** - packages that can be used to add additional info to log events (process id, thread id, machine name, etc.)
- **sinks** - a selection of output destinations, including DBMSes, cloud-based services, and third-party services

1. Install the core package and MS SQL Server sink
```sh
dotnet add package Serilog.AspNetCore
dotnet add package Serilog.Sinks.MsSqlServer
```

2. Configure Serilog to write to a SQL Server database, including the `writeToProviders: true` configuration to make sure that the logs also get shown to the other logging providers you configured.
```csharp
builder.Host.UseSerilog((ctx, lc) =>  
{  
    lc.ReadFrom.Configuration(ctx.Configuration);  
    lc.WriteTo.MSSqlServer(  
        connectionString:  
        ctx.Configuration.GetConnectionString("DefaultConnection"),  
        sinkOptions: new MSSqlServerSinkOptions  
        {  
            TableName = "LogEvents",  
            AutoCreateSqlTable = true,  
        });  
},  
    writeToProviders: true);
```

3. Now that we've added and configured Serilog, it will override all the logging configuration in `Logging` section in app settings. You need to add a separate configuration section for Serilog to mimic the minimum log level configuration.
```json
"Logging": { ... },
"Serilog": {
	"MinimumLevel": {
		"Default": "Information",
		"Override": {
			"Microsoft.AspNetCore": "Warning",
			"MyBGList": "Debug"
		}
	}
}
```

4. (Optional) Add enrichers from packages like `Serilog.Enrichers.Environment` and `Serilog.Enrichers.Thread`
```csharp
builder.Host.UseSerilog((ctx, lc) => {
	lc.Enrich.WithMachineName();
	lc.Enrich.WithThreadId();
```

prev: [[6 - Data Validation & Error Handling]]
next: [[7 - Logging]]