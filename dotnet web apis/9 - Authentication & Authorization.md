 q> **authentication** is the act of verifying the correct identity of a computer, software or user; **authorization** is the process by which a system makes it possible to assign permissions to individual computers, software, or users

#### Authentication
Authentication is a mechanism to verify that an entity is what or who they claim to be. It's of utmost importance since it plays a key role in data protection, security, and monitoring. If you can uniquely verify the identify of a connecting subject to your web service, all actions performed within the system can be traced back to their authors.

#### Authorization
Authorization is handled by through the implementation of access policies or claims that allow or prohibit a relevant action. These access control lists (ACLs) specify:
- the access type allowed for a certain resource e.g. read, write, delete
- which computers, software, or users are granted or denied access

Authorization is often intertwined with authentication because they go-hand-in-hand. Most access control mechanisms do the following:
- assign the lowest possible permissions to non-authenticated users
- authenticate users who login successfully
- check their ACLs to assign proper permissions to authenticated users
- authorize users to access the restricted content or not, depending on their permissions

![[authentication-and-authorization.png]]

##### Implementation
If HTTP is stateless -- requests do not have any knowledge about the requests that came before it, how can we know whether the user has been authenticated?

**sessions / cookies**
- this method relies on a key-value store to store user authentication info (the session), assigning it a unique session ID
- the session ID is sent to the browser via a cookie so that it'll be resent on all subsequent requests and used on the server to retrieve the user's session and act accordingly

**bearer tokens**
- this method relies on an encrypted token generated by the authentication server containing the relevant authentication info
- the token is sent to the client, which can use it in an HTTP header so it wouldn't need further authentication

#### .NET Core Identity
.NET Core Identity provides a set of interfaces and high-level abstractions that can be used to manage and store user accounts in any .NET Core app.

##### Adding Authentication Capabilities with Identity
###### The Identity Service
1. Install the NuGet packages
```sh
dotnet add package Microsoft.Extensions.Identity.Core
dotnet add package Microsoft.AspNetCore.Identity.EntityFrameworkCore
dotnet add package Microsoft.AspNetCore.Authentication.JwtBearer
```

2. Create the user model and extend the `IdentityUser` class of .NET Identity
```csharp
public class ApiUser : IdentityUser { }
```

3. Update the `DbContext` base class of EF Core to handle the Identity functionalities
```csharp
using Microsoft.AspNetCore.Identity.EntityFrameworkCore;

public class ApplicationDbContext : IdentityDbContext<ApiUser>  
{  
    public ApplicationDbContext(DbContextOptions<ApplicationDbContext> options) : base(options) { }
```

4. Add a new migration and apply it to the database
```sh
dotnet ef migrations add Identity
dotnet ef database update Identity
```

5. Set up the Identity service that will be performing the register and service functionality. You provide the minimum password strength requirements
```csharp
builder.Services.AddIdentity<ApiUser, IdentityRole>(options =>  
    {  
        options.Password.RequireDigit = true;  
        options.Password.RequireLowercase = true;  
        options.Password.RequireUppercase = true;  
        options.Password.RequireNonAlphanumeric = true;  
        options.Password.RequiredLength = 12;  
    })
    .AddEntityFrameworkStores<ApplicationDbContext>();
```

###### The Authentication Service
1. Add the authentication service that will (1) define JWTs as the default authentication method, (2) enable the JWT bearer authentication method, and (3) set up the JWT validation, issuing, and lifetime settings
```csharp
builder.Services.AddAuthentication(options =>  // set the default auth-related schemes
{  
    options.DefaultAuthenticateScheme =  
	options.DefaultChallengeScheme =  
	options.DefaultForbidScheme =  
	options.DefaultScheme =  
	options.DefaultSignInScheme =  
	options.DefaultSignOutScheme = JwtBearerDefaults.AuthenticationScheme;  
}).AddJwtBearer(options =>   // enables the JWT authentication method
{  
    options.TokenValidationParameters = new TokenValidationParameters
    {  // configure how the authentication service should validate the token
        ValidateIssuer = true,  
        ValidIssuer = builder.Configuration["JWT:Issuer"],  
        ValidateAudience = true,  
        ValidAudience = builder.Configuration["JWT:Audience"],  
        ValidateIssuerSigningKey = true,  
        IssuerSigningKey = new SymmetricSecurityKey(Encoding.UTF8.GetBytes(builder.Configuration["JWT:SigningKey"]!))  
    };
});
```

2. Set the configuration variables needed for the issuer, audience, and signing key, ideally as environment variables
```json
"JWT" : {
	"Issuer": "MyBGList",
	"Audience": "MyBGList",
	"SigningKey": "MySecretSigningKey"
}
```

3. Add the authentication middleware before the authorization middleware
```csharp
app.UseAuthentication();
app.UseAuthorization();
```

###### The AccountController
1. Add the boilerplate code
```csharp
[ApiController]  
[Route("[controller]/[action]")]  
public class AccountController : ControllerBase  
{  
    private readonly ApplicationDbContext _context;  
    private readonly ILogger<AccountController> _logger;  
    private readonly IConfiguration _configuration;  
    private readonly UserManager<ApiUser> _userManager;  
    private readonly SignInManager<ApiUser> _signInManager;  
  
    public AccountController(  
        ApplicationDbContext context,  
        ILogger<AccountController> logger,  
        IConfiguration configuration,  
        UserManager<ApiUser> userManager,  
        SignInManager<ApiUser> signInManager)  
    {
	     _context = context;  
        _logger = logger;  
        _configuration = configuration;  
        _userManager = userManager;  
        _signInManager = signInManager;  
    }  
    
    [HttpPost]  
    [ResponseCache(NoStore = true)]  
    public async Task<ActionResult> Register()  
    {
	    throw new NotImplementedException();  
    }  
    
    [HttpPost]  
    [ResponseCache(NoStore = true)]  
    public async Task<ActionResult> Login()  
    {
	    throw new NotImplementedException();  
    }
}
```

2. Create a register DTO
```csharp
public class RegisterDTO  
{  
    [Required]  
    public string? UserName { get; set; }  
	
	[Required]  
    [EmailAddress]  
    public string? Email { get; set; }  
	
	[Required]  
    public string? Password { get; set; }  
}
```

3. Implement the register action method with the help of the `UserManager` service
```csharp
[HttpPost]  
[ResponseCache(NoStore = true)]  
public async Task<ActionResult> Register(RegisterDTO input)  
{  
    var newUser = new ApiUser();  
    newUser.UserName = input.UserName;  
    newUser.Email = input.Email;  
    var result = await _userManager.CreateAsync(newUser, input.Password);  
    if (result.Succeeded)  
    {
	    _logger.LogInformation("User ({UserName} {Email}) has been created", newUser.UserName, newUser.Email);  
        return StatusCode(201, $"New user has been created ({newUser.UserName}) {newUser.Email})");  
    }
    throw new Exception($"Error: {string.Join(" ", result.Errors.Select(e => e.Description))}");  
}
```

4. Implement the login method 
```csharp
[HttpPost]  
[ResponseCache(NoStore = true)]  
public async Task<ActionResult> Login(LoginDTO input)  
{  
    try  
    {  
        var user = await _userManager.FindByNameAsync(input.UserName);  
  
        if (user is null || !await _userManager.CheckPasswordAsync(user, input.Password))  
        {
	        throw new Exception($"Invalid login attempt");  
        }  
        
        var signingCredentials = new SigningCredentials(  
	        new SymmetricSecurityKey(Encoding.UTF8.GetBytes(_configuration["JWT:SigningKey"])),  
            SecurityAlgorithms.HmacSha256);  
  
        var claims = new List<Claim>();  
  
        claims.Add(new Claim(ClaimTypes.Name, user.UserName));  
  
        var jwtObject = new JwtSecurityToken(  
            issuer: _configuration["JWT:Issuer"],  
            audience: _configuration["JWT:Audience"],  
            claims: claims,  
            expires: DateTime.Now.AddSeconds(300),  
            signingCredentials: signingCredentials);  
  
        var jwtString = new JwtSecurityTokenHandler().WriteToken(jwtObject);  
        return StatusCode(200, jwtString);  
    }
    catch (Exception e)  
    {
	    var exceptionDetails = new ProblemDetails();  
        exceptionDetails.Detail = e.Message;  
        exceptionDetails.Status = StatusCodes.Status401Unauthorized;  
        exceptionDetails.Type = "https://tools.ietf.org/html/rfc7231#section-6.6.1";  
        return StatusCode(StatusCodes.Status401Unauthorized, exceptionDetails);  
    }
}
```

##### Adding Authorization Capabilities
You have to take care of both the **client-side** (making Swagger send JWT tokens in requests), and **server-side** (make some of the action methods only accessible to those who have a JWT).
###### Client-side
1. Add a new security definition to tell Swagger the type of protection we want for our API, and a new security requirement to enforce it globally. Once you've added this, you can use the Authorize button in Swagger to add  JWT for the HTTP requests
```csharp
builder.Services.AddSwaggerGen(options =>  
{  
    options.AddSecurityDefinition("Bearer", new OpenApiSecurityScheme  
    {  
        In = ParameterLocation.Header,  
        Description = "Please enter token",  
        Name = "Authorization",  
        Type = SecuritySchemeType.Http,  
        BearerFormat = "JWT",  
        Scheme = "bearer"  
    });  
	
	options.AddSecurityRequirement(new OpenApiSecurityRequirement  
    {  
        {            new OpenApiSecurityScheme  
            {  
                Reference = new OpenApiReference  
                {  
                    Type = ReferenceType.SecurityScheme,  
                    Id = "Bearer"  
                }  
            },            Array.Empty<string>()  
        }
    });
});
```

###### Server-side
You apply the `[Authorize]` attribute controllers, action methods, and minimal API endpoints, to set specific authorization rules based on authentication schemes, policies and/or roles.
1. Decide which action methods should be restricted and unrestricted

2. Decorate these methods with the `[Authorize]` attribute. When used without parameters, it will restrict access to authenticated users regardless of their permissions.
```csharp
[Authorize]
[HttpPost]
public async Task<RestDTO<BoardGame?>> Post(BoardGameDTO model) {
```

3. Choose the default access behavior. Adding `[Authorize]` to individual action methods / endpoints like this means that the default is to allow unauthorized requests. To reverse this, add `[Authorize]` to the controller itself, then add `[AllowAnonymous]` to the unrestricted action methods.
```csharp
[Authorize]
[ApiController]
[Route("[controller]")]
public class SeedController : ControllerBase {
```

##### Role-based Access Control (RBAC)
Adding authorization allows you to distinguish between authorized and non-authorized users. However, you'd need more granular control in some cases, authorizing some only some users to do something.

Role-based Access Control (RBAC) is an authorization strategy that offers a convenient way to assign different permissions to different users. Each role is like a group, so you can add users and set up specific authorization rules for it. When the rules are defined, they'll be applied to all users who have that particular role.

**Case-study**
You want to support 3 different types of users: (1) basic users who can access read-only endpoints only, (2) moderators who can access read-only and update endpoints, and (3) administrators who can access both read-only and update endpoints, plus the delete endpoints and the ability to seed the database.

1. Create users to be assigned the roles

2. Create the new roles (add static classes for their names)

3. Add the roles and assign them with the help of the role manager
```csharp
[HttpPut("/AuthData")]  
public async Task<IActionResult> AuthData()  
{  
    var rolesCreated = 0;  
    var usersAddedToRoles = 0;  
  
    if (!await _roleManager.RoleExistsAsync(RoleNames.Moderator))  
    {
	    await _roleManager.CreateAsync(new IdentityRole(RoleNames.Moderator));  
        rolesCreated++;
	}  
    
    if (!await _roleManager.RoleExistsAsync(RoleNames.Administrator))  
    {
	    await _roleManager.CreateAsync(new IdentityRole(RoleNames.Administrator));  
        rolesCreated++;
	}  
	
    var testModerator = await _userManager.FindByNameAsync("TestModerator");  
  
    if (testModerator is not null &&  
        !await _userManager.IsInRoleAsync(testModerator, RoleNames.Moderator))  
    {
	    await _userManager.AddToRoleAsync(testModerator, RoleNames.Moderator);  
        usersAddedToRoles++;
    }
    
    var testAdministrator = await _userManager.FindByNameAsync("TestAdministrator");  
  
    if (testAdministrator is not null &&  
        !await _userManager.IsInRoleAsync(testAdministrator, RoleNames.Administrator))  
    {
	    await _userManager.AddToRoleAsync(testAdministrator, RoleNames.Moderator);  
        await _userManager.AddToRoleAsync(testAdministrator, RoleNames.Administrator);  
        usersAddedToRoles++;
    }
      
    return new JsonResult(new  
    {  
        RolesCreated = rolesCreated,  
        UsersAddedToRoles = usersAddedToRoles,  
    });  
}
```

4. Add the roles to the bearer token so the authorization middleware can check for them and act accordingly. Add the following lines in the login method
```csharp
claims.AddRange(  
    (await _userManager.GetRolesAsync(user))  
        .Select(r => new Claim(ClaimTypes.Role, r)));
```

5. Update the authorization rules to take the new roles into account
```csharp
[Authorize(Roles = RoleNames.Moderator)]
```


prev: [[8 - Caching]]
