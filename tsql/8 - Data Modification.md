### Inserting Data
There are several statements you can use to insert data into tables

**INSERT VALUES**
You can use this to insert rows into a table based on specified values

```sql
INSERT INTO dbo.Orders(orderid, orderdate, empid, custid)
VALUES(10001, '20240212', 3, 'A');
```

Specifying the columns after the table name is optional. But by doing so, you can control the order of the values that you use in the `VALUES` part. If you don't specify the columns, the order that will be used is the order used in the `CREATE TABLE` statement.

You can also use a standard `VALUES` clause to insert multiple values at a time. This is considered as 1 transaction ie if one of the inserts fail, none of the rows get inserted.

```sql
INSERT INTO [dbo].[Orders](orderid, orderdate, empid, custid)
VALUES
	(10001, '20240212', 3, 'B'),
	(10001, '20240212', 3, 'C'),
	(10001, '20240212', 3, 'D');
```

**INSERT SELECT**
`INSERT SELECT` is like `INSERT VALUES` except you use a SELECT statement to specify what rows you want to add to a target table. The rows returned will be the ones inserted. A similar statement is `SELECT INTO` which is just like `INSERT SELECT` except the table being inserted to hasn't been created yet.

```sql
INSERT INTO [dbo].[Orders](orderid, orderdate, empid, custid)
SELECT orderid, orderdate, empid, custid
FROM [Sales].[Orders]
WHERE shipcountry = N'UK';
```

**INSERT EXEC**
Once again, this is similar to both `INSERT SELECT` and `INSERT VALUES`, except you use a stored procedure to return the rows you want to add.

```sql
INSERT INTO [dbo].[Orders]
EXEC Sales.GetOrders @country = N'France'
```

**BULK INSERT**
This statement inserts data coming from a file into a table.


#### Generating numeric keys
SQL Server supports two ways you can automatically generate numeric keys: the identity column property and the sequence object.

**IDENTITY**
Identity is a column property used to generate surrogate keys ie keys that don't come from any business rule. You can add them to any numeric column that has no fraction. You can also add a seed, which is a starting value, and an increment number. Adding neither defaults both to 1.

When you add this property to a column, you shouldn't specify a value for it in `INSERT` statements.

```sql
CREATE TABLE dbo.T1
(
	keycol INT NOT NULL IDENTITY(1, 1)
);
```

You can also refer to the identity column of a table with `$identity`
```sql
SELECT $identity FROM dbo.T1
```

You can also grab the most recently used identity values generated by the session. This is useful for example if you want to add child rows to a referencing table.

Use `@@identity` if you don't care about scope, and `SCOPE_IDENTITY` if you do.

```sql
INSERT INTO [dbo].[T1](datacol)
VALUES('AAAAA');

SELECT SCOPE_IDENTITY();
```

But if you want the last generated identity regardless of the session, use `IDENT_CURRENT` and provide the table name as input.

```sql
SELECT IDENT_CURRENT('dbo.T1')
```

Some of the shortcomings of the identity property is that regardless of whether the transaction was successful or not, the scope identity gets incremented anyway. Also, removing / adding this property to already existing columns is cumbersome. Moreover, you can only insert by specifying the `IDENTITY_INSERT` to on, but you cannot update the values.

**Sequences**
A sequence is a more flexible way of generating numeric keys. One of the advantages is that they're not tied to a specific column, and so when you want a new key, you just invoke a function against the value.

The minimum required value is just the name of the sequence, and it will assume the defaults.
```sql
CREATE SEQUENCE dbo.SeqOrderIDS;
```

You can specify the data type, but its default value is `BIGINT`
```sql
CREATE SEQUENCE dbo.SeqOrderIDS AS INT;
```

You can also specify a minimum and maximum value, but the default is the range of the data type used. It also supports cycling, but you have to be explicit about it
```sql
CREATE SEQUENCE dbo.SeqOrderIDS 
	MINVALUE 1
	MAXVALUE 10
	CYCLE;
```

Like the identity property, you can specify a starting value and an increment. But its defaults are equal to `MINVALUE`
```sql
CREATE SEQUENCE dbo.SeqOrderIDS
	START WITH 1
	INCREMENT BY 1;
```

And to generate a new value from the sequence, you invoke the standard function `NEXT VALUE FOR`
```sql
SELECT NEXT VALUE FOR dbo.SeqOrderIDS;
```

If you wanna check the current value of a sequence, you can enter:
```sql
SELECT current_value
FROM sys.sequences
WHERE OBJECT_ID = OBJECT_ID(N'dbo.SeqOrderIDS');
```

---
### Deleting data
You can delete specific rows that evaluate to true when a filter is provided
```sql
DELETE FROM [dbo].[Orders]
WHERE orderdate < '20150101';
```

You can also join tables in a `DELETE` statement to get information from other tables to use in the filter condition. However, this is nonstandard, and if you want to do this in other SQL flavors, you can use subqueries
```sql
DELETE FROM O
FROM [dbo].[Orders] AS O
	INNER JOIN [dbo].[Customers] AS C
		ON O.custid = C.custid
WHERE C.country = N'USA';
```

You can also use `TRUNCATE` to delete all the rows in an entire table and it would be faster than using `DELETE` since it has minimal logging
```sql
TRUNCATE TABLE [dbo].[T1];
```

---
### Modifying data
You can modify data with the `UPDATE` statement. You use a `WHERE` clause to specify a subset of the rows to be updated, and `SET` followed by a comma-separated list of column and values to update the values of the rows. SQL also supports compound operators such as `+=`, `-=`, etc. 

```sql
UPDATE [dbo].[OrderDetails]
	SET discount = discount + 0.05
WHERE productid = 51;
```

`UPDATE` also supports updating based on a join.

```sql
UPDATE OD
	SET discount += 0.05
FROM dbo.OrderDetails OD
	INNER JOIN dbo.Orders AS O
		ON OD.orderid = O.orderid
WHERE O.custid = 1;
```

**Assignment UPDATE**
You also can use the `UPDATE` statement to both update rows and set a variable at the same time.

```sql
DECLARE @nextval AS INT;

UPDATE dbo.MySequences
	SET @nextval = val += 1
WHERE id = 'SEQ1';

SELECT @nextval;
```

---

### OUTPUT
The OUTPUT clause is useful if you want to return data about the rows you've just modified. It's similar to a SELECT clause, except you prefix the attributes with either the *inserted* or *deleted* keyword. Inserts use *inserted*, deletes use *deleted*. For updates, use *deleted* for the old state and *inserted* for the new state.

**INSERT with OUTPUT**
```sql
INSERT INTO dbo.T1(datacol)
	OUTPUT inserted.keycol, inserted.datacol
		SELECT lastname
		FROM HR.Employees
		WHERE country = N'USA';
```

**DELETE with OUTPUT**
```sql
DELETE FROM dbo.Orders
	OUTPUT
		deleted.orderid,
		deleted.orderdate,
		deleted.empid,
		deleted.custid
WHERE orderdate < '20160101';
```

**UPDATED with OUTPUT**
```sql
UPDATE dbo.OrderDetails
	SET discount += 0.05
OUTPUT
	inserted.orderid,
	inserted.productid,
	deleted.discount AS olddiscount,
	inserted.discount AS newdiscount
WHERE productid = 51;
```








